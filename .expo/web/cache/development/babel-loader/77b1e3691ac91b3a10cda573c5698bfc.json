{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = SourceLoaderUri;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _RenderTTree = _interopRequireDefault(require(\"./RenderTTree\"));\n\nvar _sourceLoaderContext = _interopRequireDefault(require(\"./context/sourceLoaderContext\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar ERROR_STATE = {\n  error: true,\n  resolvedHTML: null\n};\n\nfunction loadHTMLResource(uri, _ref) {\n  var body, headers, method, response, html;\n  return _regeneratorRuntime.async(function loadHTMLResource$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          body = _ref.body, headers = _ref.headers, method = _ref.method;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(fetch(uri, {\n            body: body,\n            headers: headers,\n            method: method\n          }));\n\n        case 3:\n          response = _context.sent;\n\n          if (!response.ok) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 7;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 7:\n          html = _context.sent;\n          return _context.abrupt(\"return\", {\n            resolvedHTML: html,\n            error: false\n          });\n\n        case 9:\n          return _context.abrupt(\"return\", ERROR_STATE);\n\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction useUriSourceLoader(_ref2) {\n  var source = _ref2.source,\n      onHTMLLoaded = _ref2.onHTMLLoaded;\n\n  var _ref3 = (0, _react.useState)({\n    error: false,\n    resolvedHTML: null\n  }),\n      _ref4 = _slicedToArray(_ref3, 2),\n      loadState = _ref4[0],\n      setState = _ref4[1];\n\n  var error = loadState.error;\n  (0, _react.useEffect)(function () {\n    var cancelled = false;\n\n    if (!error) {\n      setState({\n        error: false,\n        resolvedHTML: null\n      });\n      loadHTMLResource(source.uri, {\n        body: source.body,\n        headers: source.headers,\n        method: source.method\n      }).then(function (state) {\n        !cancelled && setState(state);\n      }).catch(function () {\n        !cancelled && setState(ERROR_STATE);\n      });\n    }\n\n    return function () {\n      cancelled = true;\n    };\n  }, [error, source.uri, source.body, source.headers, source.method]);\n  (0, _react.useEffect)(function () {\n    loadState.resolvedHTML && (onHTMLLoaded === null || onHTMLLoaded === void 0 ? void 0 : onHTMLLoaded.call(null, loadState.resolvedHTML));\n  }, [loadState.resolvedHTML, onHTMLLoaded]);\n  return loadState;\n}\n\nfunction SourceLoaderUri(props) {\n  var _ref5 = (0, _react.useContext)(_sourceLoaderContext.default),\n      remoteErrorView = _ref5.remoteErrorView,\n      remoteLoadingView = _ref5.remoteLoadingView;\n\n  var _useUriSourceLoader = useUriSourceLoader(props),\n      resolvedHTML = _useUriSourceLoader.resolvedHTML,\n      error = _useUriSourceLoader.error;\n\n  if (error) {\n    return remoteErrorView.call(null, props.source);\n  }\n\n  if (resolvedHTML === null) {\n    return remoteLoadingView.call(null, props.source);\n  }\n\n  return _react.default.createElement(_RenderTTree.default, {\n    document: resolvedHTML,\n    baseUrl: props.source.uri\n  });\n}","map":{"version":3,"sources":["SourceLoaderUri.tsx"],"names":["ERROR_STATE","error","resolvedHTML","method","response","fetch","body","headers","html","onHTMLLoaded","cancelled","setState","loadHTMLResource","source","state","loadState","remoteLoadingView","sourceLoaderContext","useUriSourceLoader","remoteErrorView","props","RenderTTree","document","baseUrl","uri"],"mappings":"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","sourcesContent":["import React, { useContext, useEffect, useState } from 'react';\nimport { HTMLSourceUri } from './shared-types';\nimport { SourceLoaderProps } from './internal-types';\nimport RenderTTree from './RenderTTree';\nimport sourceLoaderContext from './context/sourceLoaderContext';\n\ninterface LoaderInternalState {\n  error: boolean;\n  resolvedHTML: string | null;\n}\n\nconst ERROR_STATE = {\n  error: true,\n  resolvedHTML: null\n};\n\nasync function loadHTMLResource(\n  uri: string,\n  { body, headers, method }: Omit<HTMLSourceUri, 'uri'>\n): Promise<LoaderInternalState> {\n  const response = await fetch(uri, {\n    body,\n    headers,\n    method\n  });\n  if (response.ok) {\n    const html = await response.text();\n    return {\n      resolvedHTML: html,\n      error: false\n    };\n  }\n  return ERROR_STATE;\n}\n\nexport type UriSourceLoaderProps = {\n  source: HTMLSourceUri;\n} & SourceLoaderProps;\n\nfunction useUriSourceLoader({ source, onHTMLLoaded }: UriSourceLoaderProps) {\n  const [loadState, setState] = useState<LoaderInternalState>({\n    error: false,\n    resolvedHTML: null\n  });\n  const { error } = loadState;\n\n  // Effect to reload on uri changes\n  useEffect(() => {\n    let cancelled = false;\n    if (!error) {\n      setState({ error: false, resolvedHTML: null });\n      loadHTMLResource(source.uri, {\n        body: source.body,\n        headers: source.headers,\n        method: source.method\n      })\n        .then((state) => {\n          !cancelled && setState(state);\n        })\n        .catch(() => {\n          !cancelled && setState(ERROR_STATE);\n        });\n    }\n    return () => {\n      cancelled = true;\n    };\n  }, [error, source.uri, source.body, source.headers, source.method]);\n  useEffect(() => {\n    loadState.resolvedHTML && onHTMLLoaded?.call(null, loadState.resolvedHTML);\n  }, [loadState.resolvedHTML, onHTMLLoaded]);\n  return loadState;\n}\n\nexport default function SourceLoaderUri(props: UriSourceLoaderProps) {\n  const { remoteErrorView, remoteLoadingView } =\n    useContext(sourceLoaderContext);\n  const { resolvedHTML, error } = useUriSourceLoader(props);\n  if (error) {\n    return remoteErrorView.call(null, props.source);\n  }\n  if (resolvedHTML === null) {\n    return remoteLoadingView.call(null, props.source);\n  }\n  return React.createElement(RenderTTree, {\n    document: resolvedHTML!,\n    baseUrl: props.source.uri\n  });\n}\n"]},"metadata":{},"sourceType":"script"}