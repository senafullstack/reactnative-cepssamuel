{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hoist = hoist;\n\nvar _TBlockCtor = _interopRequireDefault(require(\"../tree/TBlockCtor\"));\n\nvar _TPhrasingCtor = require(\"../tree/TPhrasingCtor\");\n\nvar _TTextCtor = require(\"../tree/TTextCtor\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction groupText(tnode) {\n  var newChildren = [];\n  var wrapperInit = {\n    elementModel: null,\n    context: tnode.init.context,\n    parentStyles: tnode.styles,\n    parent: null\n  };\n  var wrapper = new _TPhrasingCtor.TPhrasingCtor(wrapperInit);\n  var wrapperChildren = [];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(tnode.children), _step; !(_step = _iterator()).done;) {\n    var child = _step.value;\n\n    if (child instanceof _TTextCtor.TTextCtor || child instanceof _TPhrasingCtor.TPhrasingCtor) {\n      wrapperChildren.push(child);\n    } else {\n      if (wrapperChildren.length) {\n        newChildren.push(wrapper);\n        wrapper.bindChildren(wrapperChildren);\n        wrapper = new _TPhrasingCtor.TPhrasingCtor(wrapperInit);\n        wrapperChildren = [];\n      }\n\n      newChildren.push(child);\n    }\n  }\n\n  if (wrapperChildren.length) {\n    wrapper.bindChildren(wrapperChildren);\n    newChildren.push(wrapper);\n  }\n\n  tnode.bindChildren(newChildren);\n  return tnode;\n}\n\nfunction hoistNode(tnode) {\n  if (tnode instanceof _TTextCtor.TTextCtor) {\n    return tnode;\n  }\n\n  tnode.bindChildren(tnode.children.map(hoistNode));\n\n  if (tnode instanceof _TPhrasingCtor.TPhrasingCtor) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(tnode.children), _step2; !(_step2 = _iterator2()).done;) {\n      var cnode = _step2.value;\n\n      if (cnode instanceof _TBlockCtor.default) {\n        var newNode = new _TBlockCtor.default(tnode.cloneInitParams());\n        newNode.bindChildren(tnode.children);\n        var output = groupText(newNode);\n        return output;\n      }\n    }\n  } else if (tnode instanceof _TBlockCtor.default) {\n    if (tnode.children.length > 0) {\n      var _output = groupText(tnode);\n\n      return _output;\n    }\n  }\n\n  return tnode;\n}\n\nfunction hoist(tree) {\n  return hoistNode(tree);\n}","map":{"version":3,"sources":["hoist.ts"],"names":["newChildren","wrapperInit","elementModel","context","tnode","parentStyles","parent","wrapper","TPhrasingCtor","wrapperChildren","child","TTextCtor","cnode","TBlockCtor","newNode","output","groupText","hoistNode"],"mappings":";;;;;;;;;;;;;AAAA,IAAA,WAAA,GAAA,sBAAA,CAAA,OAAA,sBAAA,CAAA;;AAEA,IAAA,cAAA,GAAA,OAAA,yBAAA;;AACA,IAAA,UAAA,GAAA,OAAA,qBAAA;;;;;;;;AAMA,SAAA,SAAA,CAAA,KAAA,EAAiD;AAC/C,MAAIA,WAAwB,GAA5B,EAAA;AACA,MAAMC,WAAW,GAAG;AAClBC,IAAAA,YAAY,EADM,IAAA;AAElBC,IAAAA,OAAO,EAAEC,KAAK,CAALA,IAAAA,CAFS,OAAA;AAMlBC,IAAAA,YAAY,EAAED,KAAK,CAND,MAAA;AAOlBE,IAAAA,MAAM,EAAE;AAPU,GAApB;AASA,MAAIC,OAAO,GAAG,IAAIC,cAAAA,CAAJ,aAAA,CAAd,WAAc,CAAd;AACA,MAAIC,eAA4B,GAAhC,EAAA;;AACA,uDAAoBL,KAAK,CAAzB,QAAA,wCAAoC;AAAA,QAApC,KAAoC;;AAClC,QAAIM,KAAK,YAAYC,UAAAA,CAAjBD,SAAAA,IAA8BA,KAAK,YAAYF,cAAAA,CAAnD,aAAA,EAAkE;AAChEC,MAAAA,eAAe,CAAfA,IAAAA,CAAAA,KAAAA;AADF,KAAA,MAEO;AACL,UAAIA,eAAe,CAAnB,MAAA,EAA4B;AAC1BT,QAAAA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA;AACAO,QAAAA,OAAO,CAAPA,YAAAA,CAAAA,eAAAA;AACAA,QAAAA,OAAO,GAAG,IAAIC,cAAAA,CAAJ,aAAA,CAAVD,WAAU,CAAVA;AACAE,QAAAA,eAAe,GAAfA,EAAAA;AACD;;AACDT,MAAAA,WAAW,CAAXA,IAAAA,CAAAA,KAAAA;AACD;AACF;;AACD,MAAIS,eAAe,CAAnB,MAAA,EAA4B;AAC1BF,IAAAA,OAAO,CAAPA,YAAAA,CAAAA,eAAAA;AACAP,IAAAA,WAAW,CAAXA,IAAAA,CAAAA,OAAAA;AACD;;AACDI,EAAAA,KAAK,CAALA,YAAAA,CAAAA,WAAAA;AACA,SAAA,KAAA;AACD;;AAED,SAAA,SAAA,CAAA,KAAA,EAAgD;AAC9C,MAAIA,KAAK,YAAYO,UAAAA,CAArB,SAAA,EAAgC;AAC9B,WAAA,KAAA;AACD;;AACDP,EAAAA,KAAK,CAALA,YAAAA,CAAmBA,KAAK,CAALA,QAAAA,CAAAA,GAAAA,CAAnBA,SAAmBA,CAAnBA;;AACA,MAAIA,KAAK,YAAYI,cAAAA,CAArB,aAAA,EAAoC;AAClC,0DAAoBJ,KAAK,CAAzB,QAAA,2CAAoC;AAAA,UAApC,KAAoC;;AAClC,UAAIQ,KAAK,YAAYC,WAAAA,CAArB,OAAA,EAAiC;AAC/B,YAAMC,OAAO,GAAG,IAAID,WAAAA,CAAJ,OAAA,CAAeT,KAAK,CAApC,eAA+BA,EAAf,CAAhB;AACAU,QAAAA,OAAO,CAAPA,YAAAA,CAAqBV,KAAK,CAA1BU,QAAAA;AACA,YAAMC,MAAM,GAAGC,SAAS,CAAxB,OAAwB,CAAxB;AACA,eAAA,MAAA;AACD;AACF;AARH,GAAA,MASO,IAAIZ,KAAK,YAAYS,WAAAA,CAArB,OAAA,EAAiC;AACtC,QAAIT,KAAK,CAALA,QAAAA,CAAAA,MAAAA,GAAJ,CAAA,EAA+B;AAC7B,UAAMW,OAAM,GAAGC,SAAS,CAAxB,KAAwB,CAAxB;;AACA,aAAA,OAAA;AACD;AACF;;AACD,SAAA,KAAA;AACD;;AAEM,SAAA,KAAA,CAAA,IAAA,EAA2C;AAChD,SAAOC,SAAS,CAAhB,IAAgB,CAAhB;AACD","sourcesContent":["import TBlockCtor, { TBlockImpl } from '../tree/TBlockCtor';\nimport { TNodeImpl } from '../tree/tree-types';\nimport { TPhrasingCtor } from '../tree/TPhrasingCtor';\nimport { TTextCtor } from '../tree/TTextCtor';\n\n/**\n * Wrap text nodes around TPhrasing nodes.\n * @param tnode The parent node of all elements to group.\n */\nfunction groupText(tnode: TBlockImpl): TNodeImpl {\n  let newChildren: TNodeImpl[] = [];\n  const wrapperInit = {\n    elementModel: null,\n    context: tnode.init.context,\n    // We need to merge styles here to make sure\n    // some React Native styles working only for the uppermost Text element\n    // such as \"textAlign\" are preserved.\n    parentStyles: tnode.styles,\n    parent: null\n  };\n  let wrapper = new TPhrasingCtor(wrapperInit);\n  let wrapperChildren: TNodeImpl[] = [];\n  for (const child of tnode.children) {\n    if (child instanceof TTextCtor || child instanceof TPhrasingCtor) {\n      wrapperChildren.push(child);\n    } else {\n      if (wrapperChildren.length) {\n        newChildren.push(wrapper);\n        wrapper.bindChildren(wrapperChildren);\n        wrapper = new TPhrasingCtor(wrapperInit);\n        wrapperChildren = [];\n      }\n      newChildren.push(child);\n    }\n  }\n  if (wrapperChildren.length) {\n    wrapper.bindChildren(wrapperChildren);\n    newChildren.push(wrapper);\n  }\n  tnode.bindChildren(newChildren);\n  return tnode;\n}\n\nfunction hoistNode(tnode: TNodeImpl): TNodeImpl {\n  if (tnode instanceof TTextCtor) {\n    return tnode;\n  }\n  tnode.bindChildren(tnode.children.map(hoistNode));\n  if (tnode instanceof TPhrasingCtor) {\n    for (const cnode of tnode.children) {\n      if (cnode instanceof TBlockCtor) {\n        const newNode = new TBlockCtor(tnode.cloneInitParams());\n        newNode.bindChildren(tnode.children);\n        const output = groupText(newNode);\n        return output;\n      }\n    }\n  } else if (tnode instanceof TBlockCtor) {\n    if (tnode.children.length > 0) {\n      const output = groupText(tnode);\n      return output;\n    }\n  }\n  return tnode;\n}\n\nexport function hoist(tree: TNodeImpl): TNodeImpl {\n  return hoistNode(tree);\n}\n"]},"metadata":{},"sourceType":"script"}