{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TPhrasingCtor = exports.default = void 0;\n\nvar _HTMLContentModel = _interopRequireDefault(require(\"../model/HTMLContentModel\"));\n\nvar _TNodeCtor = _interopRequireDefault(require(\"./TNodeCtor\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction isChildEmpty(c) {\n  return c.isEmpty();\n}\n\nvar TPhrasingCtor = function TPhrasing(init) {\n  this.initialize(init);\n};\n\nexports.TPhrasingCtor = TPhrasingCtor;\nTPhrasingCtor.prototype = new _TNodeCtor.default('phrasing', 'TPhrasing');\n\nTPhrasingCtor.prototype.matchContentModel = function matchContentModel(contentModel) {\n  return contentModel === _HTMLContentModel.default.textual || contentModel === _HTMLContentModel.default.mixed;\n};\n\nTPhrasingCtor.prototype.isEmpty = function isEmpty() {\n  return this.tagName === null && this.children.every(isChildEmpty);\n};\n\nTPhrasingCtor.prototype.collapseChildren = function collapseChildren() {\n  var previous = null;\n  this.children.forEach(function (childK, k) {\n    var j = k - 1;\n    childK.collapse();\n\n    if (j > -1 && childK.isCollapsibleLeft() && previous.isCollapsibleRight()) {\n      childK.trimLeft();\n    }\n\n    previous = childK;\n  });\n  this.trimLeft();\n  this.trimRight();\n  return null;\n};\n\nvar _default = TPhrasingCtor;\nexports.default = _default;","map":{"version":3,"sources":["TPhrasingCtor.ts"],"names":["c","TPhrasingCtor","TNodeCtor","contentModel","HTMLContentModel","previous","j","k","childK"],"mappings":";;;;;;;AAAA,IAAA,iBAAA,GAAA,sBAAA,CAAA,OAAA,6BAAA,CAAA;;AACA,IAAA,UAAA,GAAA,sBAAA,CAAA,OAAA,eAAA,CAAA;;;;;;;;AAKA,SAAA,YAAA,CAAA,CAAA,EAAoC;AAClC,SAAOA,CAAC,CAAR,OAAOA,EAAP;AACD;;AAED,IAAMC,aAAa,GAAG,SAAA,SAAA,CAAA,IAAA,EAGpB;AACA,OAAA,UAAA,CAAA,IAAA;AAJF,CAAA;;;AAQAA,aAAa,CAAbA,SAAAA,GAA0B,IAAIC,UAAAA,CAAJ,OAAA,CAAA,UAAA,EAA1BD,WAA0B,CAA1BA;;AAEAA,aAAa,CAAbA,SAAAA,CAAAA,iBAAAA,GAA4C,SAAA,iBAAA,CAAA,YAAA,EAE1C;AACA,SACEE,YAAY,KAAKC,iBAAAA,CAAAA,OAAAA,CAAjBD,OAAAA,IACAA,YAAY,KAAKC,iBAAAA,CAAAA,OAAAA,CAFnB,KAAA;AAHFH,CAAAA;;AASAA,aAAa,CAAbA,SAAAA,CAAAA,OAAAA,GAAkC,SAAA,OAAA,GAAmB;AAEnD,SAAO,KAAA,OAAA,KAAA,IAAA,IAAyB,KAAA,QAAA,CAAA,KAAA,CAAhC,YAAgC,CAAhC;AAFFA,CAAAA;;AAKAA,aAAa,CAAbA,SAAAA,CAAAA,gBAAAA,GAA2C,SAAA,gBAAA,GAA4B;AACrE,MAAII,QAA0B,GAA9B,IAAA;AACA,OAAA,QAAA,CAAA,OAAA,CAAsB,UAAA,MAAA,EAAA,CAAA,EAAe;AACnC,QAAMC,CAAC,GAAGC,CAAC,GAAX,CAAA;AACAC,IAAAA,MAAM,CAANA,QAAAA;;AACA,QACEF,CAAC,GAAG,CAAJA,CAAAA,IACAE,MAAM,CADNF,iBACAE,EADAF,IAECD,QAAD,CAHF,kBAGGA,EAHH,EAIE;AAGAG,MAAAA,MAAM,CAANA,QAAAA;AACD;;AACDH,IAAAA,QAAQ,GAARA,MAAAA;AAZF,GAAA;AAcA,OAAA,QAAA;AACA,OAAA,SAAA;AACA,SAAA,IAAA;AAlBFJ,CAAAA;;eAqBeA,a","sourcesContent":["import HTMLContentModel from '../model/HTMLContentModel';\nimport TNodeCtor, { GenericTNodeCtor, Mutable } from './TNodeCtor';\nimport { TNodeImpl, TNodeInit } from './tree-types';\n\nexport interface TPhrasingImpl extends TNodeImpl {}\n\nfunction isChildEmpty(c: TNodeImpl) {\n  return c.isEmpty();\n}\n\nconst TPhrasingCtor = function TPhrasing(\n  this: Mutable<TNodeImpl>,\n  init: TNodeInit\n) {\n  this.initialize(init);\n} as Function as GenericTNodeCtor<TNodeInit, TPhrasingImpl>;\n\n//@ts-ignore\nTPhrasingCtor.prototype = new TNodeCtor('phrasing', 'TPhrasing');\n\nTPhrasingCtor.prototype.matchContentModel = function matchContentModel(\n  contentModel\n) {\n  return (\n    contentModel === HTMLContentModel.textual ||\n    contentModel === HTMLContentModel.mixed\n  );\n};\n\nTPhrasingCtor.prototype.isEmpty = function isEmpty() {\n  // Only anonymous phrasing nodes with every children empty can be considered \"empty\"\n  return this.tagName === null && this.children.every(isChildEmpty);\n};\n\nTPhrasingCtor.prototype.collapseChildren = function collapseChildren() {\n  let previous: TNodeImpl | null = null;\n  this.children.forEach((childK, k) => {\n    const j = k - 1;\n    childK.collapse();\n    if (\n      j > -1 &&\n      childK.isCollapsibleLeft() &&\n      (previous as TNodeImpl).isCollapsibleRight()\n    ) {\n      // We must trim left from current to support trimming\n      // after <br> and <wbr> tags.\n      childK.trimLeft();\n    }\n    previous = childK;\n  });\n  this.trimLeft();\n  this.trimRight();\n  return null;\n};\n\nexport default TPhrasingCtor;\n\nexport { TPhrasingCtor };\n"]},"metadata":{},"sourceType":"script"}