{"ast":null,"code":"\"use strict\";var _classCallCheck=require(\"@babel/runtime/helpers/classCallCheck\");var _createClass=require(\"@babel/runtime/helpers/createClass\");var _inherits=require(\"@babel/runtime/helpers/inherits\");var _possibleConstructorReturn=require(\"@babel/runtime/helpers/possibleConstructorReturn\");var _getPrototypeOf=require(\"@babel/runtime/helpers/getPrototypeOf\");function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}Object.defineProperty(exports,\"__esModule\",{value:true});exports.LongFontFamilyPropertyValidator=void 0;var _LongCSSPropertyValidator=require(\"./LongCSSPropertyValidator\");var _normalizeFontName=_interopRequireDefault(require(\"./normalizeFontName\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var SEPARATOR_REGEX=/,\\s*/;var LongFontFamilyPropertyValidator=function(_LongCSSPropertyValid){_inherits(LongFontFamilyPropertyValidator,_LongCSSPropertyValid);var _super=_createSuper(LongFontFamilyPropertyValidator);function LongFontFamilyPropertyValidator(){_classCallCheck(this,LongFontFamilyPropertyValidator);return _super.apply(this,arguments);}_createClass(LongFontFamilyPropertyValidator,[{key:\"normalizeRawInlineCSSValue\",value:function normalizeRawInlineCSSValue(value){var values=value.split(SEPARATOR_REGEX);for(var _iterator=_createForOfIteratorHelperLoose(values),_step;!(_step=_iterator()).done;){var font=_step.value;var normalizedFont=(0,_normalizeFontName.default)(font);var isFontSupported=normalizedFont.length&&this.config.isFontSupported(normalizedFont);if(isFontSupported){return typeof isFontSupported==='string'?isFontSupported:normalizedFont;}}return null;}},{key:\"normalizeNativeValue\",value:function normalizeNativeValue(value){return this.normalizeInlineCSSValue(value);}}]);return LongFontFamilyPropertyValidator;}(_LongCSSPropertyValidator.LongCSSPropertyValidator);exports.LongFontFamilyPropertyValidator=LongFontFamilyPropertyValidator;","map":{"version":3,"sources":["LongFontFamilyPropertyValidator.ts"],"names":["SEPARATOR_REGEX","LongCSSPropertyValidator","normalizeRawInlineCSSValue","values","value","normalizedFont","isFontSupported","normalizeNativeValue"],"mappings":"+qEAAA,GAAA,CAAA,yBAAA,CAAA,OAAA,8BAAA,CACA,GAAA,CAAA,kBAAA,CAAA,sBAAA,CAAA,OAAA,uBAAA,CAAA,C,mFAGA,GAAMA,CAAAA,eAAe,CAArB,MAAA,C,GAEO,CAAA,+B,uXAGLE,oCAA0B,KAA1BA,CAAyD,CACvD,GAAMC,CAAAA,MAAM,CAAGC,KAAK,CAALA,KAAAA,CAAf,eAAeA,CAAf,CACA,kDAAA,MAAA,mCAA2B,IAA3B,CAAA,IAA2B,aACzB,GAAMC,CAAAA,cAAc,CAAG,CAAA,EAAA,kBAAA,CAAA,OAAA,EAAvB,IAAuB,CAAvB,CACA,GAAMC,CAAAA,eAAe,CACnBD,cAAc,CAAdA,MAAAA,EAAyB,KAAA,MAAA,CAAA,eAAA,CAD3B,cAC2B,CAD3B,CAEA,GAAA,eAAA,CAAqB,CACnB,MAAO,OAAA,CAAA,eAAA,GAAA,QAAA,CAAA,eAAA,CAAP,cAAA,CAGD,CACF,CACD,MAAA,KAAA,CACD,C,oCACDE,8BAAoB,KAApBA,CAAoC,CAClC,MAAO,MAAA,uBAAA,CAAP,KAAO,CAAP,CACD,C,6CAjBON,yBAAAA,CAFH,wB","sourcesContent":["import { LongCSSPropertyValidator } from './LongCSSPropertyValidator';\nimport normalizeFontName from './normalizeFontName';\nimport { CSSPropertyModel } from './types';\n\nconst SEPARATOR_REGEX = /,\\s*/;\n\nexport class LongFontFamilyPropertyValidator<\n  C extends CSSPropertyModel\n> extends LongCSSPropertyValidator<C, string> {\n  normalizeRawInlineCSSValue(value: string): string | null {\n    const values = value.split(SEPARATOR_REGEX);\n    for (const font of values) {\n      const normalizedFont = normalizeFontName(font);\n      const isFontSupported =\n        normalizedFont.length && this.config.isFontSupported(normalizedFont);\n      if (isFontSupported) {\n        return typeof isFontSupported === 'string'\n          ? isFontSupported\n          : normalizedFont;\n      }\n    }\n    return null;\n  }\n  normalizeNativeValue(value: string) {\n    return this.normalizeInlineCSSValue(value);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}